

type UserData<T> = interface {
    fn cool() -> T[]
    fn clone() -> UserData<T>
}

type ConcreteUserData<T> = class UserData<T> {
    let age: T

    fn init(v: T) {
        this.age = v
    }

    fn cool() -> T[] {
        return [this.age, this.age+1]
    }

    fn clone() -> UserData<T> {
        let c = new ConcreteUserData<T>()
        c.age = this.age
        return c
    }
}

let c = new ConcreteUserData<i32>(10)
let c2 = c.clone()