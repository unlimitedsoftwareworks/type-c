type A = interface {
    fn methodA() -> void
}

type B = interface {
    fn methodB() -> void
}

type C = interface {
    fn methodC() -> void
}

type D = interface A, B{
    fn methodD() -> void
}
type E = interface A {
    fn methodE() -> void
}


type DClass = class D {
    fn methodA() -> void {}
    fn methodB() -> void {}
    fn methodC() -> void {}
    fn methodD() -> void {}
}


let deepOptional: ((A & B) & C) ? = new DClass() // should be valid

let deepUnwrap: ((A & B) & C) = deepOptional! // should be valid


fn main(){
}